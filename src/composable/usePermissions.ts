import { useUserStoreHook } from "@/store/modules/user"

const isInteger = Number.isInteger,
    isNegative = (num: number | bigint): boolean => num < 0;

class BitOperationUtil {
    public static isValidNonNegativeInteger(num: number | bigint): boolean {
        return (typeof num === 'number' && isInteger(num) || typeof num === 'bigint') 
            && !isNegative(num);
    }

    public static isValidBitmark(num: number | bigint): boolean {
        if (num <= 0 || num <= 0n) return false;
        if (typeof num === 'number') {
            return (num & (num - 1)) === 0;
        } else {
            return (num & (num - 1n)) === 0n;
        }
    }

    public static calculateBinaryDigitLength(num: number | bigint): number {
        if (num === 0 || num === 0n) return 0;
        return num.toString(2).length;
    }

    public static generateBitmark(bitOffset: number): number | bigint {
        return bitOffset < 53
            ? 1 << bitOffset
            : 1n << BigInt(bitOffset);
    }

    public static verifyBitmark(target: number | bigint, bitmark: number | bigint): boolean {
        if (typeof target === 'number' && typeof bitmark === 'number') {
            return (target & bitmark) === bitmark;
        } else if (typeof target === 'bigint' && typeof bitmark === 'bigint') {
            return (target & bitmark) === bitmark;
        } else {
            return false;
        }
    }

    public static addBitmark(target: number | bigint, bitmark: number | bigint): number | bigint {
        if (typeof target === 'number' && typeof bitmark === 'number') {
            return target | bitmark;
        } else if (typeof target === 'bigint' && typeof bitmark === 'bigint') {
            return target | bitmark;
        }
        return target;
    }

    public static removeBitmark(target: number | bigint, bitmark: number | bigint): number | bigint {
        if (typeof target === 'number' && typeof bitmark === 'number') {
            return target & ~bitmark;
        } else if (typeof target === 'bigint' && typeof bitmark === 'bigint') {
            return target & ~bitmark;
        }
        return target;
    }
}

class Permissions {
    static #instance: Permissions | null = null;
    #permissionValue: number | bigint;
    #bitOffset: number;
    #generatedBitmarks = new Set<number | bigint>();

    static readonly #ERRORS = Object.freeze({
        INVALID_INIT_VALUE: 'Initial permission value must be a non-negative integer',
        INVALID_PERMISSION_STATE: 'Permission value is invalid (must be non-negative integer)',
        INVALID_BITMARK: 'Bitmark must be a positive integer (valid permission flag, 2^n format)',
        FORGED_BITMARK: 'Bitmark is not generated by this instance (forged or expired)',
    } as const);

    private constructor(initialPermissionValue: number | bigint) {
        this.#validatePermissionValue(initialPermissionValue);
        this.#permissionValue = initialPermissionValue;
        this.#bitOffset = BitOperationUtil.calculateBinaryDigitLength(initialPermissionValue);
    }

    public static getInstance(initialPermissionValue: number | bigint = 0): Permissions {
        if (!this.#instance) {
            const validInitVal = BitOperationUtil.isValidNonNegativeInteger(initialPermissionValue)
                ? initialPermissionValue
                : 0;
            this.#instance = new Permissions(validInitVal);
        }
        return this.#instance;
    }

    public gen(): number | bigint {
        this.#validatePermissionState();

        const bitmark = BitOperationUtil.generateBitmark(this.#bitOffset);

        this.#generatedBitmarks.add(bitmark);
        this.#bitOffset += 1;
        return bitmark;
    }

    public verify(bitmark: any): boolean {
      if (![ 'number', 'bigint' ].includes(typeof bitmark) || 
          !BitOperationUtil.isValidNonNegativeInteger(bitmark) || 
          !BitOperationUtil.isValidBitmark(bitmark)) {
        console.warn(`Invalid bitmark provided: ${bitmark}`);
        return false;
      }
      
      this.#validatePermissionState();
  
      return BitOperationUtil.verifyBitmark(this.#permissionValue, bitmark);
    }

    public add(bitmark: number | bigint): this {
        this.#validateBitmark(bitmark);
        this.#validatePermissionState();

        this.#permissionValue = BitOperationUtil.addBitmark(this.#permissionValue, bitmark);
        return this;
    }

    public remove(bitmark: number | bigint): this {
        this.#validateBitmark(bitmark);
        this.#validatePermissionState();

        this.#permissionValue = BitOperationUtil.removeBitmark(this.#permissionValue, bitmark);
        return this;
    }

    public reset(newPermissionValue: number | bigint = 0): this {
        const validVal = BitOperationUtil.isValidNonNegativeInteger(newPermissionValue)
            ? newPermissionValue
            : 0;
        this.#permissionValue = validVal;
        this.#bitOffset = BitOperationUtil.calculateBinaryDigitLength(validVal);
        this.#generatedBitmarks.clear();
        return this;
    }

    public get value(): number | bigint {
        return this.#permissionValue;
    }

    public get generatedBitmarks(): (number | bigint)[] {
        return Array.from(this.#generatedBitmarks);
    }

    #validatePermissionValue(value: number | bigint): void {
        if (!BitOperationUtil.isValidNonNegativeInteger(value)) {
            throw new Error(Permissions.#ERRORS.INVALID_INIT_VALUE);
        }
    }

    #validatePermissionState(): void {
        if (!BitOperationUtil.isValidNonNegativeInteger(this.#permissionValue)) {
            throw new Error(Permissions.#ERRORS.INVALID_PERMISSION_STATE);
        }
    }

    #validateBitmark(bitmark: number | bigint): void {
        if (!BitOperationUtil.isValidNonNegativeInteger(bitmark) || !BitOperationUtil.isValidBitmark(bitmark)) {
            throw new Error(Permissions.#ERRORS.INVALID_BITMARK);
        }
    }
}

export function usePermissions(): Permissions {
    return Permissions.getInstance(useUserStoreHook().UserData?.role || 0);
}